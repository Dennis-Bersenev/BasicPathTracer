Answers:
1.
The function is getting the ray passing through each pixel, we need this function in-order to shoot rays through the view plane onto which we are projecting our image.In a bit more detail, the supplied parameters can be thought of as proportions of the horizontal/vertical dimensions indicating how far across/down we are along the image plane, which are then offset by the lower left corner and origin (of the camera), providing a pixel on the image plane through which the ray is being cast.In short, this function is responsible for casting the initial ray into the scene.  
2.
There's two reasons behind doing this. The first is because it is our method for simulating scattering effects, this algorithm, being a path tracer, only follows one ray, and using material properties, chooses random directions in which to direct the ray. By shooting many rays through the same pixel we are able to simulate this random scattering and the various lighting effects it produces. The second thing this code does, on account of it randomly choosing a point through the pixel on each iteration, is provide antialiasing; specifically, multi-sample antialiasing, eliminating the "jaggies" of rendered objects.
3.
It is a recursive function used to compute the ray's final colour.The passed in parameters are the ray, by reference to make sure the same ray is used,the world (of objects the ray can potentially hit), and the ray's depth, which is used to control how deep the recursion stack can grow.The first condition ensures this limit is never exceeded.The second, can be thought of as the main recursive branch, it will continuously call the colour function with the nearest object hit (handled by hit function for hitable_list objects). Attenuating the ray (based on colour of material of nearest intersection), and updating the ray's properties is handled inside the material class. Invalid scatter directions correspond to absorption of the ray by the object, thus recursion ends and the final colour is black (since ray was absorbed by an object it intersected it'll never reach the eye); otherwise, recursion continues with the updated ray and attenuated addition to the product which will produce the final colour.Any miss results in a premature return (base case of recursion), such a return will send back the background colour (sky-blue).The final computed colour, for a standard execution, will simply be the products of attenuation terms for each intersection with the ambient background colour.
4.
In general, the purpose of the scatter function is to handle incident rays.Oncoming rays are used to produce the new outgoing rays, both origin and direction.Outgoing rays with invalid directions are handled to prematurely end the algorithm (through boolean return), and the attenuation (which colour channels the objects reflects; therefore, how incident light colours are modified) is computed and returned for use in main::colour().  The Lambertian scatter function simply chooses a random (in the approximate half sphere relative to the surface) about the point of intersection as the direction for the outgoing ray; whereas, the metal's scatter function computes a random direction in a cone about the reflection direction. 
5.
It is a pointer, but the object it is referencing is a hitable_list , which is a derived class of the abstract hitable object. The hit function of a hitable_list is responsible for finding the closest intersection of a ray with an object in the scene. It invokes the hit function on each of its elements to determine which ones the ray intersects, keeping track of the closest intersection using the hit record, and eventually returning, at which point the passed-by-reference hit record will store the information for the nearest ray-object intersection, or will be unchanged. The boolean return value indicating to the caller whether any hits took place or not.We need to keep track of the closes_so_far variable in order to keep track of which object has had the closest intersection with the ray so far. The object intersecting the ray the nearest, relative to the ray's origin, will be the one for which t was smallest (ray took the least amount of time to reach). This t-val is then passed into the hit function for subsequent objects in the hit_list as t_max, if any object's calculated intersection has a t > t_max then its hit function returns false. Keeping track of this variable is what allows us to cleanly maintain the nearest object intersecting the ray.
6.
Sphere objects store a center point, a material object, and a radius.Being completely honest, the derivation given in lecture felt unintuitive and I do not understand it, my approach to calculating ray-sphere intersections is to use the technique we learned in Math 200 (multivariable calculus).With this approach, you use the explicit equation of a sphere:(x-c1)^2 + (y-c2)^2 + (z-c3)^2 = r^2, where the center is at (c1, c2, c3), rewritten in vector form using the L2-norm as || p - c ||^2 = r^2And the parametric equation of the ray: r(t) = ro + rd*tObserve that if the two intersect, then at their point of intersection r(t) will satisfy the above equation for the sphere, i.e. r(t) = p || r(t) - c ||^2 = r^2Skipping some algebraic expansion steps, the result will look like this:t^2 (rd*rd) + 2t (rd*(ro - c)) + (ro - c)*(ro - c) = r^2Notice this can be solved using the quadratic formulat = (-b +/- sqrt(b^2 - 4ac))/2aa = rd^2, b =2(rd*(ro - c)), c = (ro - c)*(ro - c) - r^2This is the intersection point formula, and derivation that is intuitive to me and is the one I use.Peter Shirley's algorithm for computing ray/sphere intersections is modeled off this as well.He essentially does the exact some thing except for ignoring the constants, then uses conditionals to handle the results.If the discriminant is negative, there are no real roots, implying no solutions, return false (no intersection between ray and sphere).Otherwise, check the two potential values for t, noting that the computation using -b - sqrt(discriminant) must always be smaller than -b + sqrt(discriminant) for a valid intersection; hence, why that is checked first.The values for t are then further pruned based on if they are below t_min (in-order to prevent self intersections and incorrect directions), or above t_max (t_max is generally given as the t-value of the closest so far, so if t is larger than it must not be the nearest intersection, or it is outside our defined scene boundary).If, however, the conditions are satisfied then the computed t value is returned.That being said, I believe this is not computing the hit-point using the same method used in-class since it closely resembles the method I use, which is different from that taught in-class. The in-class method uses geometry and trigonometry, the method presented above uses a method involving systems of equations for explicit objects (a ray and sphere).